#include <stdio.h>
#include <pcap.h>
#include "marine.h"
#include <string.h>
#include <assert.h>
#include <time.h>
#include <stdlib.h>
#include <sys/resource.h>
#include <zconf.h>

#define CASES 7


typedef struct {
    struct pcap_pkthdr *header;
    const u_char *data;
} packet;


/*
* Author:  David Robert Nadeau
* Site:    http://NadeauSoftware.com/
* License: Creative Commons Attribution 3.0 Unported License
*          http://creativecommons.org/licenses/by/3.0/deed.en_US
*/
size_t get_current_rss(void) {
    long rss = 0L;
    FILE *fp = NULL;
    if ((fp = fopen("/proc/self/statm", "r")) == NULL) {
        return (size_t) 0L;
    }
    if (fscanf(fp, "%*s%ld", &rss) != 1) {
        fclose(fp);
        return (size_t) 0L;
    }
    fclose(fp);
    return (size_t) rss * (size_t) sysconf(_SC_PAGESIZE);
}

int load_cap(char *file, packet **packets, char errbuff[PCAP_ERRBUF_SIZE]) {
    printf("Start loading packets from cap\n");

    pcap_t *pcap = pcap_open_offline(file, errbuff);
    if (pcap == NULL) {
        return -1;
    }

    int allocated_packets = 10000;
    int p_count = 0;
    struct pcap_pkthdr *header;
    const u_char *data;

    packet* inner_packets = (packet *)malloc(sizeof(packet) * allocated_packets);
    while (pcap_next_ex(pcap, &header, &data) >= 0) {

        if (p_count >= allocated_packets) {
            allocated_packets *= 2;
            inner_packets = (packet * )realloc(inner_packets, allocated_packets * sizeof(packet));
        }

        packet p = {header, data};
        inner_packets[p_count] = p;
        p_count++;
    }
    inner_packets = (packet *)realloc(inner_packets, p_count * sizeof(packet));
    *packets = inner_packets;
    printf("Cap has been loaded, %d packets were loaded\n", p_count);
    return p_count;
}

void benchmark(packet packets[], int packet_len, char *bpf, char *display_filter, char *fields[], int fields_len) {
    char err_msg[512];
    int filter_id = marine_add_filter(bpf, display_filter, fields, fields_len, err_msg);

    if (filter_id < 0) {
        fprintf(stderr,"Error creating filter id: %s\n", err_msg);
        return;
    }

    size_t memory_start = get_current_rss();
    clock_t start = clock();
    for (int i = 0; i < packet_len; ++i) {
        packet p = packets[i];
        marine_result *packet_results = marine_dissect_packet(filter_id, (char *) p.data, p.header->len);
        assert(packet_results->result == 1);
        marine_free(packet_results);
    }
    clock_t end = clock();
    size_t memory_end = get_current_rss();

    float total_time = ((float) end - start) / CLOCKS_PER_SEC;
    float pps = (float) packet_len / total_time;
    float memory_usage = ((float) memory_end - memory_start) / 1024 / 1024;
    printf("%d packets took: %f Sec, which is %f pps!\n The test took: %lf MB\n", 30000, total_time, pps,
           memory_usage);
}

int print_title(char *str) {
    return printf("\n\033[4:1m%s\033[0m\n", str);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: ./marine_benchmark <path to cap generated by cap_maker.py>\n");
        return -1;
    }

    char *cap_file = argv[1];
    packet *packets;
    char errbuff[PCAP_ERRBUF_SIZE];
    int packet_count = load_cap(cap_file, &packets, errbuff);
    if (packet_count < 0) {
        fprintf(stderr,"\nCouldn't load the cap %s\n", errbuff);
        return -1;
    }

    int packet_per_case = packet_count / CASES;

    int part = 0;
    char *bpf = "tcp portrange 4000-4019 or udp portrange 4000-4019";
    char *dfilter = "((tcp.srcport >= 4000 and tcp.srcport <= 4019)"
                    " or "
                    "(tcp.dstport >= 4000 and tcp.dstport <= 4019))"
                    " or "
                    "((udp.srcport >= 4000 and udp.srcport <= 4019)"
                    " or "
                    "(udp.dstport >= 4000 and udp.dstport <= 4019))";
    char *three_fields[] = {
            "ip.proto",
            "eth.dst",
            "ip.host"
    };
    char *eight_fields[] = {
            "ip.proto",
            "eth.dst",
            "ip.host",
            "eth.src",
            "eth.type",
            "ip.hdr_len",
            "ip.version",
            "frame.encap_type"
    };

    init_marine();
    size_t memory_start = get_current_rss();
    print_title("Benchmark with BPF");

    // By doing `packets + (packet_per_case * part++)` we will make sure that each case will have they own unique packets
    benchmark(packets + (packet_per_case * part++), packet_per_case, bpf, NULL, NULL, 0);

    print_title("Benchmark with Display filter");
    benchmark(packets + (packet_per_case * part++), packet_per_case, NULL, dfilter, NULL, 0);

    print_title("Benchmark with BPF and Display filter");
    benchmark(packets + (packet_per_case * part++), packet_per_case, bpf, dfilter, NULL, 0);

    print_title("Benchmark with three extracted fields");
    benchmark(packets + (packet_per_case * part++), packet_per_case, NULL, NULL, three_fields, 3);

    print_title("Benchmark with eight extracted fields");
    benchmark(packets + (packet_per_case * part++), packet_per_case, NULL, NULL, eight_fields, 8);

    print_title("Benchmark with BPF, Display filter and three extracted fields");
    benchmark(packets + (packet_per_case * part++), packet_per_case, bpf, dfilter, three_fields, 3);

    print_title("Benchmark with BPF, Display filter and eight extracted fields");
    benchmark(packets + (packet_per_case * part), packet_per_case, bpf, dfilter, eight_fields, 8);

    size_t memory_end = get_current_rss();
    printf("Total memory usage: %lf MB\n", (((float) memory_end - memory_start) / 1024 / 1024));
    free(packets);
    destroy_marine();
    return 0;
}

